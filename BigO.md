
Big O
=====

Big O показывает __верхнюю границу зависимости__ между __входными параметрами__ *функции* и __количеством операций__. Верхняя граница - наихудший вариант развития событий.

+ O(1) - постоянная, константная
+ O(log N) - логарифмическая
+ O(N) - линейная, прямо пропорциональная
+ O(N²) - квадратичная


Вычисление Big O
----------------

Последовательность действий, операций - сложение.

+ O(A + B)

Кол-во B операций выполняется A раз (вложенные действия) - умножение.

+ O(A * B)

Big O описывает только __скорость роста__ кол-ва операций, поэтому константы необходимо отбрасывать, так как они незначительны.

+ O(2N) = O(N)
+ O(N² + N²) = O(2N²) = O(N²)
+ O(N + 1) = O(N)
+ O(log₂ N) = O(log N)

Если сложность O(A) в два раза (*значительно*) больше сложности O(B), сложность O(B) является такой же незначительной, как и константы.

+ O(N² + N) = O(N²)
+ O(5 * 2ⁿ + 10 * N¹⁰⁰) = O(2ⁿ + N¹⁰⁰) = O(2ⁿ)

Сложность O(L) значительна, т.к. о ней ничего не известно.

+ O(N² + L) = O(N² + L)

Сложность алгоритма __включает__ O(log N), если на каждой итерации или на каждом рекурсивном вызове этого алгоритма берется __половина__ входных данных, элементов.  







