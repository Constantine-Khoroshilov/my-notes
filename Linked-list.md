# Связанный список

Это структура данных, которая представляет собой список данных,
состоящий из **узлов**. Связанный список позволяет осуществлять 
удаление и вставку элементов более удобным способом, чем 
классический массив, т. к. размер связанного списка не 
является фиксированным.  

* __Однонаправленный__. Такой связанный список, в котором каждый 
*предыдущий* узел имеет ссылку на *следующий* узел.

```c#

class Node {
    Node next;
    int data;
    Node(int data) { this.data = data; }
}

```

* __Двунаправленный__. Такой связанный список, в котором каждый
узел имеет ссылку как на *следующий узел, так и на предыдущий*.

```c#

class Node {
    Node next;
    Node prev;
    int data;
    Node(int data) { this.data = data; }
}

```

У связанного списка есть указатель на его начало - *head*, который соответственно является 
первым узлом списка, и указатель на его конец - *tail*, который соответственно является 
последним узлом списка.

Связанный список обеспечивает *быструю вставку элемента в начало и конец* за O(1). 
Но удаление (*кроме удаления самого первого элемента*, к-ое выполняется также за O(1)), 
вставка в середину и чтение данных из данного списка требуют *поиск исходного элемента*, 
поэтому они выполняются за O(N).

Пример вставки элемента в начало для однонаправленного связанного списка:

```c#

void addStart(int n) {
    Node node = new Node(n);
    /* если изначально список был пуст, то добавляемый элемент
     * становится и головой, и хвостом
     */
    if (head == null) tail = node;
    else node.next = head;
    head = node;
}

```

Пример вставки элемента в конец для однонаправленного связанного списка:

```c#

void addEnd(int n) {
    Node node = new Node(n);
    /* если изначально список был пуст, то добавляемый элемент
     * становится и головой, и хвостом
     */
    if (tail == null) head = node;
    else tail.next = node;
    tail = node;
}

```

Пример вставки элемента в "середину" для однонаправленного связанного списка:

```c#

void insertAfter(int aftreN, int n) {
    Node searchNode = search(aftreN); // поиск исходного элемента в списке
    if (searchNode != null) {
        Node node = new Node(n); // новый узел для вставки

        if (searchNode == tail) tail = node;
        // меняем ссылки соответственно
        node.next = searchNode.next;
        searchNode.next = node;
    }
}

Node search(int n) {
    Node searchNode = head;
    while (searchNode != null) {
        if (searchNode.data == n) return searchNode;

        searchNode = searchNode.next; 
    }
    
    return null;
}

``` 