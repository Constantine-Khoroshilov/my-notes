# Основы ООП на примере Java

Суть ООП - выделение и описание __сущностей__, к-ые участвуют в поставленной задаче, их __свойств__ и __методов взаимодействия__


## Основные принципы

* Абстракция *(Не путать с АТД)*
* Инкапсуляция *(Не путать с сокрытием)*
* Наследование
* Полиморфизм


## Класс и объект. Основные определния и св-ва

* Класс (абстрактное, *общее* описание) - программное описание __типа данных__, к-ый описывает некоторую сущность поставленной задачи

* Св-во класса - поле данных класса (переменная, массив...), к-ое содержит __значение некотор. параметра (нектор. данные)__ сущности

* Метод класса - __функция__, к-ая *может менять св-во класса* (необязательно), т. е. описывает то, как сущность выполняет некотор. действия

* Объект (*конкретная* сущность) - конкретный __экземпляр класса__, к-ый имеет свои собственные конкретн. значения св-в

### Описание класса в Java

В Java один класс - один файл 

	public class Car {
		String color;
		String form;
		double engineV;
		double fuelConsumption; // расход на 100 км
		String id;
		double fuelInTank; // остаток топлива
		
		// заправить авто
		void fillTank(int fuelV) {
			fuelInTank = fuelInTank + fuelV;
		}
		
		// проехать расстояние
		void drive(double distance) {
			fuelInTank = fuelInTank - distance / 100 * fuelConsumption;
		}
	}

### Создание объекта в Java и взаимодействие с ним

	Car myCar = new Car(); // очевидно, что нельзя просто присвоить значение
		// new - оператор, к-ый создает объекты класса
	
	myCar.fuelInTank = 10;
	myCar.fillTank(fuelV:20);
	

### Оператор new в Java

	new <конструктор>

* Выделяет *память* под объект
* Создает *новый* объект (вызывает конструктор)
* Возвращает __ссылку__ на созданный объект

### Конструктор

* Конструктор - специальный __метод__ (функция) для *инициализации св-в объекта* во время его создания с помощью оператора new

* В Java каждый класс имеет конструктор по умолчанию *без параметров*, доступный, если не описано никаких других конструкторов

* У конструктора нет возвращаемого типа, и он называется точно так же как и класс

Конструктор(ы) описывает(ют)ся внутри класса. Конструкторов может быть несколько, они различаются *порядком следования параметров* и *их типами данных* - это называется *перегрузкой* (в данном случае конструктора) - вид **полиморфизма**

	// конструктор без параметров
	Car() {
		fuelInTank = 0;
		id = "BB001";
	}
	
	// конструктор с параметрами
	Car(String id, double fuelInTank) {
		this.fuelInTank = fuelInTank;
		this.id = id;
	}
	
	Car myCar = new Car(id:"BB001", fuelInTank:0);

**Замечание:** ключевое слово this (в Object Pascal используется self) - ссылка на *текущий* объект, экземляр класса. Может использоваться для устранения неоднозначности наименований переменных внутри объекта, конструктора (см. пример выше).

### Модификаторы доступа в Java

* public - доступно всем (*отовсюду*)
* private - доступно только *внутри класса*
* protected - доступно только *внутри класса* и его *наследникам*
* default - доступно только в *пакете класса*

Пакет (обычная директория) - метод *группировки классов* и *идентификации приложения*

Хорошая практика, что бы *все* свойства класса являлись закрытыми, чтобы нельзя было их *изменить* напрямую. Для взаимодействия со свойствами класса лучше всего использовать открытые методы:

	public class Brush {
		private String color;
		public String getColor() { // геттор
			return color;
		}
		public void setColor(String newColor) { // сеттор
			color = newColor;
		}
	}


## Наследование

Вынесение *общих свойств и методов* из каких-либо классов в один общий родительский класс

В Java нельзя наследоваться от двух классов одновременно

	// класс "Сотрудник"
	public class Employee {
		private String name;
		// для хранения денег намного лучше использовать целочисленные типы
		private long salary;
		
		// конструктор
		public Employee(String name_, long salary_) {
			name = name_;
			salary = salary_;
		}
		
		public long getSalary() {
			return salary;
		}
	}
	
	public class Doctor extends Employee {
		private int category;
	
		public Doctor(String name_, long salary_, int category_) {
			// вызываем конструктор родительского класса
			super(name_, salary_);
			category = category_;
		}
	}


## Полиморфизм. Переопределение методов в Java

### @Overload и @Override

* Перезагрузка (overload) метода/конструктора происходит, когда в *одном классе* существуют несколько методов/конструкторов с *одинаковыми именами*, но *разными параметрами* 
* Переопределение (override) метода, конструктора происходит, когда в *дочернем* классе создаётся метод/конструктор, у которого имя совпадает с именем метода/конструктора из *родительском* класса

**Замечание #1:** перегрузка и переопределение методов - это виды **полиморфизма** (возможность объектов с одинаковой спецификацией иметь различную реализацию)<br>
**Замечание #2:** в ООП под понятием полиморфизма имеется в виду его разновидность - **полиморфизм подтипов** 

### Какие методы можно переопределить

Все методы в Java являются **виртуальными** и могут быть переопределены (кроме методов final).<br>
**Замечание**: в C#, C++ можно переопределить только **виртуальные** методы, заданные через virtual

### Как работает переопределение

Пусть:

* Объект *дочернего класса* или ссылка, указатель на него хранится в переменной, тип к-ой - *родительский класс*
* В дочернем и родительском классе существуют два *одинаковых* метода, реализация к-ых разная

Тогда:

* Если метод в *дочернем* классе переопределен с помощью @Override, то будет вызвана реализация данного метода в *дочернем* классе
* Если метод в *дочернем* классе не переопределен с помощью @Override, то будет вызвана реализация данного метода в *родительском* классе

### Пример

Переопределим в дочернем классе Doctor метод getSalary, метод родительского класса Employee, с помощью @Override:

	public class Doctor extends Employee {
		private int category;
	
		public Doctor(String name_, long salary_, int category_) {
			// вызываем конструктор родительского класса
			super(name_, salary_);
			category = category_;
		}
		
		@Override
		public long getSalary() {
			return salary * 1.15; 
			// другая реализация, но название и параметры метода 
			// точно такие же как и в родительском классе 
		}
	}

В основной программе:

	public class MainClass {
		public static void main(String[] args) {
			
			// Массив сотрудников, элементами к-го могут являться объекты любого подкласса Employee
			Employee[] emps = new Employee[3];
			
			// Заполняем
			emps[0] = new Doctor(name_: "Николай", salary_: 40000, category_: 3);
			
			// Пусть есть еще один подкласс Builder, в к-ом метод getSalary имеет свою реализацию, 
			// увеличивающую ЗП вдвое, но не переопределен с помощью @Override
			emps[1] = new Builder(name_: "Андрей", salary_: 17000);
			
			for (int i = 0; i < emps.length; i++)
				System.out.print("Зарплата сотрудника: " + emps[i].getSalary());
				// Для объекта подкласса Doctor будет выведено 80000,
				// была вызвана реализация в подклассе Doctor, т. к. метод переопределен
				// Для объекта подкласса Builder будет выведено 17000,
				// была вызвана реализация в классе Employee, т. к. метод не переопределен
		}
	}



