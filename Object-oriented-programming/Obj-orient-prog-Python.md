# SOLID-принципы. Введение в ООП на Python


## Парадигма ООП

* Данные структурируются в виде объектов, каждый из к-ых имеет определенный тип, т. е. принадлежит к какому-либо классу.

* Классы - результат формализации решаемой задачи, выделения главных её аспектов.

* Внутри объекта инкапсулируется логика работы с относящейся к нему информацией.

* Объекты в программе взаимодействуют с друг другом, обмениваются запросами и ответами (не обязательно через методы).

* При этом объекты одного типа сходным образом отвечают на одни и те же запросы.

* Объекты могут организовываться в более сложные структуры, например, включать другие объекты или наследовать от одного или нескольких объектов.


## SOLID-принципы

**S** _Принцип единственной ответственности (single responsibility principle)_: Для каждого класса должно быть определено единственное назначение.

**O** _Принцип открытости/закрытости (open-closed principle)_: Программные сущности должны быть открыты для расширения (дополнение новым функционалом), но закрыты для модификации уже существующего *интерфейса* (реализация при этом может модифицироваться).

**L** _Принцип подстановки Лисков (Liskov substitution principle)_: Объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения правильности выполнения программы.

**I** _Принцип разделения интерфейсов (interface segregation principle)_: Много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения (универсальный метод, например).

**D** _Принцип инверсии зависимостей (dependency inversion principle)_: Зависимость на Абстракциях. нет зависимости на что-то конкретное. То есть необходимо создать некоторый интерфейс, а реализация нас более менее не волнует (В Java для этого есть "интерфейсы", а в Python используются абстрактные классы).


```python
class Rectangle:
	# Статический атрибут (с ним можно работать без создания объекта)
	default_color = "green"
	def __init__(self, width, height):
		# Динамические атрибуты
		self.width = width
		self.height = height
```

**Замечание:** В Python нет *перегрузки функций*, т. е. если в классе есть, например, метод \_\_init\_\_, то он обязательно один. Нет возможности создать несколько конструкторов.

**Замечание:** Статический и динамическиий атрибуты могут иметь одно и то же имя.


## "Магические" методы классов в Python

Если метод классы выглядит следующем образом __название__, то он является *спецметодом*, к-ый уже встроен в сам язык.

Пример: \_\_new\_\_, \_\_init\_\_, \_\_del\_\_ (не вполне деструктор)


## Статические и классовые методы

```python
class ToyClass:
	# Экземплярный метод
	def instancemethod(self):
		return 'instance method called', self

	@classmethod
	def classmethod(cls):
		return 'class method called', cls

	@staticmethod # обвёртка декоратором
	def staticmethod():
		return 'static method called'
```


## Абстрактные классы

Класс *абстрактный*, если он содержит минимум один *абстрактный метод*, т. е. метод, к-ый объявлен, но не реализован. В Python они не являются частью стандарта языка, поэтому для их использования необходимо использовать библиотеку *abc*.


## Обработка исключений

```python
try:
	# исполняем какой-то код
except Exception as e: # лучше всегда писать, какой исключение обрабатываем
	# обработка исключения
else:
	# код, который будет исполнен в случае, когда не возникнет исключения
finally:
	# код, который гарантированно будет исполнен последним (всегда исполняется)
```


