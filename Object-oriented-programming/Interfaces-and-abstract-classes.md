# Интерфейсы и абстрактные классы на примере Java

## Абстрактные классы

Класс назвается **абстрактным**, если он содержит *хотя бы* один **абстрактный метод** - метод без реализации (то есть в классе описана только его *сигнатура*).

```java
abstract class Car {
    String model;

    public abstract void go() {}
    public abstract void stop() {}

    public void setModel(String model) {
        this.model = model;
    }
}
```

**Замечание:** создать экземпляр и вызывать метод абстрактного класса невозможно.

Абстрактные классы создаются только для дальнейшего наследования от них с целью создания общей, базовой функциональности для *родственных*, дочерних объектов.

В дочерних классах должны быть реализованы *все* абстрактные методы их суперкласса, который соотвественно является абстрактным.

```java
class ToyotaCorolla extends Car {
    public void go() {
        System.out.println("Toyota Corolla едет");
    }

    public void stop() {
        System.out.println("Toyota Corolla остановилась");
    }
}
```

**Замечание:** в Java использовать `@Override` при переопределении абстрактных методов абстрактного класса не обязательно. В силу полиморфизма экземпляр класса `ToyotaCorolla` можно создать следующим образом:

```java
int n = 4;
Car cars[] = new Car[n];

cars[0] = new ToyotaCorolla();
cars[1] = new ToyotaCorolla();
// etc.

cars[0].go();
cars[1].stop();
// etc.
```


## Интерфейсы

Путь дана программа:

```java
abstract class Geom {
    int width, color;
    abstract void draw();
}

class Line extends Geom {
    void draw() {
        System.out.println("Рисование линии");
    } 
}

class Rectangle extends Geom {
    void draw() {
        System.out.println("Рисование прямоугольника");
    } 
}

class Triangle extends Geom {
    void draw() {
        System.out.println("Рисование треугольника");
    } 
}
```

Необходимо реализовать метод `double getSquare()` вычисления площади для объектов классов Rectangle и Triangle.

Если просто реализовать этот метод в каждом классе отдельно, то возникают две проблемы:

1. При явном или неявном *upcast* (приведение типа к родительскому классу) объекта класса `Triangle` или `Rectangle` к объекту класса `Geom` метод `double getSquare()` станет не доступен, так как он не определен в родительском классе.

2. Если при работе со всеми наследниками класса `Geom` мы будем выполнять *downcast* этих наследников к их дочернему классу, нам все равно придется делать проверку на наличие или отсутствие метода `double getSquare()`.

Т. е. обе проблемы заключаются в том, что нет общего или единого интерфейса взаимодействия. 

Эту проблему можно было легко разрешить при помощи *множественного наследования*. Например, можно создать еще один класс - `MathGeom`.

![Схема наследования классов](img/Interfaces-Scheme.svg "Схема наследования классов")

Но в Java множественное наследование не поддерживается, вместо него используются **интерфейсы**, поэтому `MathGeom` будет интерфейсом. Интерфейсы можно *воспринимать как чисто абстрактные классы*, содержащие только константы и абстрактные методы.

При создании интерфейса в Java указывать какие-либо модификаторы (`abstract`, `public`) не нужно.

```java
interface MathGeom {
    double getSquare();
}
```

Реализуем интерфейс `MathGeom` в классе `Rectangle`:

```java
class Rectangle extends Geom implements MathGeom {
    void draw() {
        System.out.println("Рисование прямоугольника");
    }

    // он должен быть public соответственно, иначе
    // смысла в использовании интерфейса нет
    public double getSquare() {
        return 0.5 * 10;
    }
}
```

В функции `Main`:

```java
public static void main(String[] args) {
    int n = 3;
    Geom g[] = new Geom[n];

    g[0] = new Line();
    g[1] = new Rectangle();
    g[2] = new Triangle();

    for (int i = 0; i < n; ++i) {
        if (g[i] instanceof MathGeom) {
            double s = ( (MathGeom) g[i] ).getSquare();
            // etc.
        }
    }
}
```

**Замечание:** при приведении типа к интерфейсу (*upcast*) все публичные методы объекта, которые не описаны в данном интерфейсе, станут недоступными (по аналогии с обычными классами). 

### Итог

1. Интерфейс - это аспект языка, который служит для того, чтобы формировать *интерфейс взаимодействия* (класса, объекта).
2. Интерфейс взаимодействия - это набор *публичных членов* класса (поля, методы, свойства).
3. Интерфейс не наследуется, он реализуется.
4. Допустима *множественная* реализация интерфейсов (заметное отличие от *абстрактного класса*).
5. Интерфейс позволяет ограничить класс определенной ролью (*single responsibility*).
6. Интерфейсы можно рассматривать как альтернативу *множественному наследованию*.