# Основы ООП на примере Java

Суть ООП - выделение и описание __сущностей__, к-ые участвуют в поставленной задаче, их __свойств__ и __методов взаимодействия__


## Основные принципы

* Абстракция (описание абстрактной сущности, класса, св-ва к-ой зависят от *конкретной* задачи)
* Инкапсуляция
* Наследование
* Полиморфизм


## Абстракция *(Не путать с АТД)*. Класс и объект

* Класс (абстрактное, *общее* описание) - программное описание __типа данных__, к-ый описывает некоторую сущность поставленной задачи

* Св-во класса - поле данных класса (переменная, массив...), к-ое содержит __значение некотор. параметра (нектор. данные)__ сущности

* Метод класса - __функция__, к-ая *может менять св-во класса* (необязательно), т. е. описывает то, как сущность выполняет некотор. действия

* Объект (*конкретная* сущность) - конкретный __экземпляр класса__, к-ый имеет свои собственные конкретн. значения св-в

### Описание класса в Java

В Java один класс - один файл 

	public class Car {
		String color;
		String form;
		double engineV;
		double fuelConsumption; // расход на 100 км
		String id;
		double fuelInTank; // остаток топлива
		
		// заправить авто
		void fillTank(int fuelV) {
			fuelInTank = fuelInTank + fuelV;
		}
		
		// проехать расстояние
		void drive(double distance) {
			fuelInTank = fuelInTank - distance / 100 * fuelConsumption;
		}
	}

### Создание объекта в Java и взаимодействие с ним

	Car myCar = new Car(); // очевидно, что нельзя просто присвоить значение
		// new - оператор, к-ый создает объекты класса
	
	myCar.fuelInTank = 10;
	myCar.fillTank(fuelV:20);
	

### Оператор new в Java

	new <конструктор>

* Выделяет *память* под объект
* Создает *новый* объект (вызывает конструктор)
* Возвращает __ссылку__ на созданный объект

### Конструктор

* Конструктор - специальный __метод__ (функция) для *инициализации св-в объекта* во время его создания с помощью оператора new

* В Java каждый класс имеет конструктор по умолчанию *без параметров*, доступный, если не описано никаких других конструкторов

* У конструктора нет возвращаемого типа, и он называется точно так же как и класс

Конструктор(ы) описывает(ют)ся внутри класса. Конструкторов может быть несколько, они различаются *порядком следования параметров* и *их типами данных*

	// конструктор без параметров
	Car() {
		fuelInTank = 0;
		id = "BB001";
	}
	
	// конструктор с параметрами
	Car(String id, double fuelInTank) {
		this.fuelInTank = fuelInTank;
		this.id = id;
	}
	
	Car myCar = new Car(id:"BB001", fuelInTank:0);

**Замечание:** ключевое слово this (в Object Pascal используется self) - ссылка на *текущий* объект, экземляр класса. Может использоваться для устранения неоднозначности наименований переменных внутри объекта, конструктора (см. пример выше).

## Инкапсуляция *(Не путать с сокрытием)*

Скрытие свойств класса, его внутренних методов и предоставление доступа к ним через *публичные* (доступные другим классам) методы

### Модификаторы доступа в Java:

* public - доступно всем (*отовсюду*)
* private - доступно только *внутри класса*
* protected - доступно только *внутри класса* и его *наследникам*
* default - доступно только в *пакете класса*

Пакет (обычная директория) - метод *группировки классов* и *идентификации приложения*

Хорошая практика, что бы *все* свойства класса являлись закрытыми, чтобы нельзя было их *изменить* напрямую. Для взаимодействия со свойствами класса лучше всего использовать открытые методы:

	public class Brush {
		private String color;
		public String getColor() { // геттор
			return color;
		}
		public void setColor(String newColor) { // сеттор
			color = newColor;
		}
	}


## Наследование

Вынесение *общих свойств и методов* из каких-либо классов в один общий родительский класс

В Java нельзя наследоваться от двух классов одновременно

	// класс "Сотрудник"
	public class Employee {
		private String name;
		// для хранения денег намного лучше использовать целочисленные типы
		private long salary;
		
		// конструктор
		public Employee(String name_, long salary_) {
			name = name_;
			salary = salary_;
		}
		
		public long getSalary() {
			return salary;
		}
	}
	
	public class Doctor extends Employee {
		private int category;
	
		public Doctor(String name_, long salary_, int category_) {
			// вызываем конструктор родительского класса
			super(name_, salary_);
			category = category_;
		}
	}


## Полиморфизм

### Переопределение методов

* Все методы в Java могут быть переопределены (кроме методов final)
  Замечание: в C#, C++ можно переопределить только *виртуальные* методы, заданные через virtual
* Если метод в *дочернем* классе переопределен, то будет вызвана реализация данного метода в *дочернем* классе
* Если метод в *дочернем* классе не переопределен, то будет вызвана реализация данного метода в *родительском* классе

### @Overload и @Override

* Перезагрузка (overload) метода/конструктора происходит, когда в *одном классе* существуют несколько методов/конструкторов с *одинаковыми именами*, но *разными параметрами* 
* Переопределение (override) метода, конструктора происходит, когда в *дочернем* классе создаётся метод/конструктор, у которого имя совпадает с именем метода/конструктора из *родительском* класса

Пример:

	public class Doctor extends Employee {
		private int category;
	
		public Doctor(String name_, long salary_, int category_) {
			// вызываем конструктор родительского класса
			super(name_, salary_);
			category = category_;
		}
		
		@Override
		public long getSalary() {
			return salary * 1.15; 
			// другая реализация, но название и параметры метода 
			// точно такие же как и в родительском классе 
		}
	}



